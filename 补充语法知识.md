- [补充代码知识](#补充代码知识)
    - [Echo](#Echo)
    - [Bash用法](#Bash用法)
    - [Cat用法](#Cat用法)
    - [文件/etc/apt/sources.list](#文件/etc/apt/sources.list)
    - [shell语句中各种符号](#shell语句中各种符号)
    - [条件判断语句if-then-fi](#条件判断语句if-then-fi)
    - [sed-i命令](#sed-i命令)
    - [export命令](#export命令)
    - [Mkdir命令](#Mkdir命令)
    - [For循环语句](#For循环语句)
    - [文件目录的切换方式](#文件目录的切换方式)
    - [Curl的使用方法](#Curl的使用方法)
    - [Eval用法](#Eval用法)
    - [Chmod用法](#Chmod用法)
    - [linux中PATH=$PATH:$HOME/bin是什么意思](#linux中PATH=$PATH:$HOME/bin是什么意思)
    - [Cd用法](#Cd用法)
    - [Lsb-release](#Lsb-release)
    - [Eval用法](#Eval用法)
    - [Chmod用法](#Chmod用法)
# Echo
1. 功能说明：显示文字。  
2. 语 法：  
```ubuntu
echo [-ne][字符串]或 echo [--help][--version]  
```

3. 补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开，并在最后加上换行号。  

4. 参 数：  
-n 不要在最后自动换行  
-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：  
\a 发出警告声；  
\b 删除前一个字符；  
\c 最后不加上换行符号；  
\f 换行但光标仍旧停留在原来的位置；  
\n 换行且光标移至行首；  
\r 光标移至行首，但不换行；  
\t 插入tab；  
\v 与\f相同；  
\\ 插入\字符；  
\nnn 插入nnn（八进制）所代表的ASCII字符；  
--help 显示帮助  
--version 显示版本信息  
每一个shell支持的echo指令可能都不太相同。  
-n 不输出最后的\n  
-e解释转义字符  
-E不解释转义字符  
5. 示例：  
a.  
```ubunut
echo "i am a boy" 
```
 执行后会打印 i am a boy  
b.  在实际应用中我们会把这条命令和重定向符号（也称为管道符号，一般用> >> ^）结合来实现输入一些命令到特定格式的文件中。譬如@echo hello simonsww >> 123.txt,执行完如上命令后，会在当前的目录的123.txt文件中，加入hello simonsww内容，从而达到修改文件内容的作用，此命令的巧妙之处就在于如果文件的扩展名不是txt，一样是达到修改文件的内容，相当于强行添加信息的作用.

# Bash用法：
1. 用法：
```ubunut
bash -c “cmd string”
```
通常使用shell去运行脚本，两种方法 bash xxx.sh，另外一种就是bash -c “cmd string”  

2.  对于bash -c “cmd string”

① bash -c  "cmd string"  接的是shell命令字符串，用双引号括起来  
② bash -c  "/path/to/file"  写文件的绝对路径，用双引号括起来，且文件要具有可执行权限

3. 对于bash xxx.sh
  
首先bash 会在当前目录去寻找xxx.sh，如果找到，就直接运行，找不到则按照环境变量$PATH的指定路径，按顺序去找，如果找到，则执行，找不到则报错。shell脚本的参数$0就是要执行的shell脚本xxx.sh， $1就是后面紧跟xxx.sh的参数，$2 $3依次类推  

# Cat用法
1. 功能说明:  
concatenate files and print on the standard output ＃连接文件并打印到标准输出，有标准输出的都可以用重定向定向导入到文件里面
2. 语法格式
```ubuntu
cat [OPTION]...[FILE]..
```
3. 基本用法  
① 查看文件内容  
```ubuntu
xuruizhi@DESKTOP-HI65AUV:~$ cat /etc/passwd   # 查看注册密码
root:x:0:0:root:/root:/bin/bash
。。。。
```
![tupian](./%E7%AC%AC%E4%BA%8C%E7%AB%A0/Setting-up%20scripts%20for%20Ubuntu%2020.04/pictures/%E5%9B%BE%E7%89%877.png)

② 把log1.txt的文件内容加上行号输入log2.txt这个文件里
```ubuntu
xuruizhi@DESKTOP-HI65AUV:~$ cat -n log1.txt
     1  2012-1
     2  2013-1
     3  2014-1
     4
     5

xuruizhi@DESKTOP-HI65AUV:~$ cat -n log1.txt>log2.txt

xuruizhi@DESKTOP-HI65AUV:~$ cat log2.txt

     1  2012-1
     2  2013-1
     3  2014-1
     4
     5
```
③ 使用cat编辑文档内容，cat>filename，创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束
cat>filename<<EOF，以EOF作为输入结束，和ctrl+d的作用一样
```ubuntu
xuruizhi@DESKTOP-HI65AUV:~$ cat >log1.txt<<EOF

> 2012-3
> 2013-3
> 2014-3
> EOF

xuruizhi@DESKTOP-HI65AUV:~$ cat log1.txt

2012-3
2013-3
2014-3
```
# 文件/etc/apt/sources.list
1. 简介：/etc/apt/sources.list 是包管理工具 apt 所用的记录软件包仓库位置的配置文件，同样的还有位于 /etc/apt/sources.list.d/*.list 的各文件。
2. sources.list 条目格式  
sources.list 文件中的条目一般都有如下所示的形式：  

deb http://site.example.com/debian distribution component1 component2 component3  
deb-src http://site.example.com/debian distribution component1 component2 component3  

①　档案类型 (Archive type)
条目的第一个词 deb 或是 deb-src 表明了所获取的软件包档案类型。
其中，
Deb，档案类型为二进制预编译软件包，一般我们所用的档案类型。
deb-src，档案类型为用于编译二进制软件包的源代码。

②　仓库地址 (Repository URL)
条目的第二个词则是软件包所在仓库的地址。我们可以更换仓库地址为其他地理位置更靠近自己的镜像来提高下载速度。

常用镜像地址列表：
Debian https://www.debian.org/mirror/list  
Ubuntu http://wiki.ubuntu.org.cn/源列表  

③　发行版 (Distribution)
跟在仓库地址后的是发行版。发行版有两种分类方法，一类是发行版的具体代号，如 xenial,trusty, precise 等；还有一类则是发行版的发行类型，如oldstable, stable, testing 和 unstable。

另外，在发行版后还可能有进一步的指定，如 xenial-updates, trusty-security, stable-backports 等

④　软件包分类 (Component)
跟在发行版之后的就是软件包的具体分类了，可以有一个或多个。

Ubuntu 对软件包的分类可以用下表来表示（参考自 Wikipedia）：
main官方支持的 自由软件。  
restricted官方支持的非完全 自由的软件。  
universe社区维护的自由软件。  
multiverse非自由软件。  

#  shell语句中各种符号
```
-e filename 如果 filename存在，则为真
-d filename 如果 filename为目录，则为真
-f filename 如果 filename为常规文件，则为真
-L filename 如果 filename为符号链接，则为真
-r filename 如果 filename可读，则为真
-w filename 如果 filename可写，则为真
-x filename 如果 filename可执行，则为真
-s filename 如果文件长度不为0，则为真
-h filename 如果文件是软链接，则为真
filename1 -nt filename2 如果 filename1比 filename2新，则为真。
filename1 -ot filename2 如果 filename1比 filename2旧，则为真。
-eq 等于
-ne 不等于
-gt 大于
-ge 大于等于
-lt 小于
-le 小于等于
！号   取非
-o   或运算
-a   和运算
&&		# 相当于与运算，满足所有条件；也用于前面成功完成才执行后面 		
||		# 相当于或运算，满足一个条件就可以；前面无论成功失败就执行后面

=	字符串是否相等；
!=  判断是否不相等;		
-z  字符串长度为0；	
-n	字符串长度不相等；		
$ 字符串为空
echo ${#a}		# 打印字符串变量a 的长度

· 举例
#!/bin/bash
a=10
b=20
val=`expr $a + $b`		# 将 + 符号换成： 减- ，乘 \* ，	除 / ，取余 %  
echo "a +b = $val"		# 响应一个字符串， 和变量的值 $val
if [ $a == $b ]			# if 如果，then 然后， echo 响应，fi 结束字句
then 					# [ $a == $b ]  用绝对等于符号判断两个字符串
    echo "a 等于 b "			
fi
```
# 条件判断语句if-then-fi
1. 基本的if-then-fi语句可以用来判断基本的单层的分支结构，其形式如下：  
```
if [条件判断式]；then
    条件判断式成立时执行的语句
fi
```


2. if-then-else-fi语句可以处理两层的分支判断语句  
```
if [条件判断式]；then
    条件判断式成立时执行的语句
else
    条件判断式不成立时执行的语句
fi 
```
* 举例：
```
#! /bin/sh

echo "Please enter a number:"#输出提示信息
read num #从键盘读取用户输入的数字
if [ "$num" -gt 10 ]; then#如果用户输入的数字大于10
		#输出大于10的提示信息
        echo "The number is greater than 10."
else#否则
	    #输出小于或者等于10的提示信息
		echo "The number is equal to or less than 10."
fi
```

3. if-then-elif-then-elif-then-...-else-fi。这种语句可以实现多重判断，注意最后一定要以一个else结尾
```
if [条件判断式1]；then
    条件判断式1 成立时执行的语句
elif[条件判断式2]；then
    条件判断式2 成立时执行的语句
else
    条件判断式1&2 均不成立时执行的语句
fi
```
* 举例
```
#! /bin/sh
echo "Please enter a score:"
read score
if [ -z "$score" ]; then
   echo "You enter nothing.Please enter a score:"
   read score
else
   if [ "$score" -lt 0 -o "$score" -gt 100 ]; then 小于0或者大于100
      echo "The score should be between 0 and 100.Please enter again:"
      read score
   else
      #如果成绩大于等于90
      if [ "$score" -ge 90 ]; then
         echo "The grade is A."
      #如果成绩大于等于80且小于90
      elif [ "$score" -ge 80 ]; then
         echo "The grade is B."
      #如果成绩大于等于70且小于80
      elif [ "$score" -ge 70 ]; then
         echo "The grade is C."
      #如果成绩大于等于60且小于70
      elif [ "$score" -ge 60 ]; then
         echo "The grade is D."
      #如果成绩小于60
      else
         echo "The grade is E."
      fi
   fi
Fi
```

4. case-esac语句实现多重条件判断
```
case $变量名称 in
    "第一个变量内容"）   #每个变量内容都用双引号括起来，关键字为小括号
        程序段
        ；； #每个类别结尾加上；；
     "第二个变量内容"）  
        程序段
        ；；
*）  #最后一个变量内容与第二个变量内容的其他程序运行段
     不包含第一个和第二个变量内容的其他程序运行段
     exit 1
     ；；
esac
``` 
* 举例
```
case "$keypress" in
    [[:lower:]])  #小写字母
      echo "Lowercase letter."
      ;;
   [[:upper:]]) #大写字母
      echo "Uppercase letter."
      ;;
   [0-9])#单个数字
      echo "Digit."
      ;;
   *) #其他字符
      echo "other letter."
      ;;
esac
```
# sed-i命令
* 对每行匹配到的第一个字符串进行替换  
sed -i 's/原字符串/新字符串/' ab.txt 
  
* 对全局匹配上的所有字符串进行替换  
sed -i 's/原字符串/新字符串/g' ab.txt 
 
* 删除所有匹配到字符串的行  
sed -i '/匹配字符串/d'  ab.txt  
 
* 特定字符串的行后插入新行  
sed -i '/特定字符串/a 新行字符串' ab.txt 
 
* 特定字符串的行前插入新行  
sed -i '/特定字符串/i 新行字符串' ab.txt
 
* 把匹配行中的某个字符串替换为目标字符串  
sed -i '/匹配字符串/s/源字符串/目标字符串/g' ab.txt
 
* 在文件ab.txt中的末行之后，添加bye  
sed -i '$a bye' ab.txt   
 
* 对于文件第3行，把匹配上的所有字符串进行替换  
sed -i '3s/原字符串/新字符串/g' ab.txt

举例：
```
#cat 1.txt
d
ddd

sed -i 's/d/7523/' /home/1.txt
执行结果
7523
7523dd


sed -i 's/d/7523/g' /home/1.txt
执行结果
7523
752375237523
```

# export命令
1. 功能说明:设置或显示环境变量。  
(比如我们要用一个命令，但这个命令的执行文件不在当前目录，这样我们每次用的时候必须指定执行文件的目录，麻烦，在代码中先执行export，这个相当于告诉程序，执行某某东西时，需要的文件或什么东西在这些目录里)

2. 语法: 
```
export [-fnp][变量名称]=[变量设置值]
```
补充说明:  在shell执行程序时， shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。


参数:  
* -f 代表[变量名称]中为函数名称。
* -n删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
* -p列出所有的shell赋予程序的环境变量。  

3. 作用  
一个变量创建时，它不会自动地为在它之后创建的shel进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原为脚本(调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本.


# Mkdir命令
1. 命令格式：
```
mkdir [选项] 目录...
```
2. 命令功能：

通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。

3. 命令参数：

* -m, --mode=模式，设定权限<模式> (类似 chmod)，而不是 rwxrwxrwx 减 umask

* -p, --parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;

* -v, --verbose 每次创建新目录都显示信息

* --help 显示此帮助信息并退出

* --version 输出版本信息并退出


# For循环语句
1. 读取in后面的值，默认以空格分隔  
举例：
```
#!/bin/bash
for var in a1 b1 c1 d1
do
	echo "this is $var"
done
```
或
```
#!/bin/bash
for var in a1 b1 c1 d1;do
	echo "this is $var"
done
```
结果：
```
xuruizhi@DESKTOP-HI65AUV:~$ for var in a1 b1 c1 d1;do
> echo "this is $var"
> done
this is a1
this is b1
this is c1
this is d1
```
2. 读取in后面值，使用引号加以约束  
举例：
```
#!/bin/bash
for var in a1 a2 "c1 d1" e2 "hello world"
do
	echo "this is $var"
Done
```
结果：
```
this is a1
this is a2
this is c1 d1
this is e2
this is hello world
```
3. 读取in后面的值，特殊符号使用转义符"/"加以约束  
举例：
```
#!/bin/bash
for var in a1 b\'1 'c1 d1' e2 'hello world' it\'s a22
do
	echo "this is $var"
done
```
结果：
```
this is a1
this is b'1
this is c1 d1
this is e2
this is hello world
this is it's
this is a22
```

4. 从变量中取值， 即提前定义列表变量  
举例：
```
#!/bin/bash

lst="a1 b1 c1 d1"
for var in $lst
do
	echo "this is $var"
done
```
结果：
```
this is a1
this is b1
this is c1 
this is d1
```
5. 从命令中取值  
举例：
```
#!/bin/bash

for i in `cat ./test.txt`
do
	echo $i
done
```
结果：
```
xuruizhi@DESKTOP-HI65AUV:~$ cat >1.txt <<EOF
> this
> is
> a
> test and message
> it is not ture
> EOF
xuruizhi@DESKTOP-HI65AUV:~$ for i in `cat ./1.txt`
> do
> echo $i
> done
this
is
a
test
and
message
it
is
not
ture
```
6. 自定义shell分隔符  
默认情况下，bash shell 会以空格、制表符、换行符作为分隔符。  
`通过IFS来自定义为分隔符`  
① 指定单个字符做分隔符：IFS=: # 以:冒号作为分隔符  
② 指定多个字符做分隔符：IFS='\n':;' #定义反斜杠、n、冒号、分号和双引号作为字段分隔符  


# 文件目录的切换方式
1. 关于cd 的使用方式  
 ① cd + 文件夹目录的方式 (相对路径或者绝对路径)  
 --cd是最通用的切换文件目录的方式，使用方式：cd + 文件夹的绝对路径  
 ② cd ..  
 --返回当前目录的上一级目录下；   
 ③ cd ~  
 --返回到当前用户的home目录下，亦即/home/用户名/目录下；  
 ④ cd -  
 --返回上一次的工作目录，因而反复使用 cd -，可以实现在两个不同目录之间来回切换

 2. 关于popd、pushd、dirs的使用方式  
 ① dirs (区别于dir：dir的功能与ls类似)  
 --显示栈顶到栈底的文件目录列表，通常显示的第一个文件目录为当前的工作目录  
 ② pushd+文件目录(相对/绝对路径)  
 --向目录栈中添加相应的文件目录，同时当前工作目录调整到相应的目录下  
 ③ pushd 单独使用  
 --调换目录栈中最近的两个目录，同时刻当前的工作目录会发生变化  
 ④ popd的工作方式  
 --弹出当前目录栈中保存的工作目录，工作目录变为栈中相应的目录


# Curl的使用方法
1. 语句
```
curl [options...] <url>
```
2. 选项  
-o, --output <file> 写入到文件，而不是输出到stdout  
-O 写入到文件，文件名和远程文件一样  
-L 跟随网站的跳转  
-x, --proxy [protocol://][user:pwd@]host[:port] 使用代理  
-v 打印过程  
--trace <file> debug写入到文件,很详细包括二进制数据交换，file使用 - 表示打印到stdout  
-c <file> 将服务器设置的cookie写入到文件  
-b <data> 发送cookie,从 string/file 获取  
-A <name> 发送 User-Agent <name> 到服务器  
-e <url> 指定 Referer : <url> , 仿造referer，服务器会以为你是从 url 点击某个链接过来的  
-H <header/@file> 将自定义标头传递到服务器  
-X <command> 指定请求方法，不带任何参数的请求默认get方法  
-s Silent mode 无声模式  
-S Show error even when -s is used 即使使用 -s 也打印错误  
-i 打印服务器回应的http标头  
-I 只打印标头  
-k 使用ssl时，允许不安全的服务器连接。跳过ssl检测  
-d <data> http post data,使用post方法发送表单,自动添加标头Content-Type : application/x-www-form-urlencoded  
-F <name=content> 指定 multipart MIME data , 可以上传二进制文件,自动添加Content-Type: multipart/form-data  
-G 把 post data 放进 url 并使用 get 请求，与-d配合  
-u <user:password> 指定服务器用户和密码  
-T <file> 上传文件，使用 put 请求   
3. 举例  
下载文件：  
```
curl -LO https://github.com/x/releases/download/v3.0.1/xxx.AppImage
curl -LO http://www.example.com/pic[1-5].JPG 循环下载
```
使用代理：
```
curl -x socks5://127.0.0.1:1080 -LO https://github.com/x/releases/download/v3.0.1/xxx.AppImage
```
post请求：
```
curl -d'login=kirito&password=123' https://google.com/login
curl -d'login=kirito' -d'password=123' https://google.com/login
```
上传文件：
```
curl -F 'file=@a.txt' https://example.com
```


# Eval用法
1. 介绍
eval是POSIX的一部分。它是一个接口，可以是一个内置的shell。  

在“POSIX程序员手册”中有描述: http://www.unix.com/man-page/posix/1posix/eval/
 * eval - construct command by concatenating arguments


2. 语句
```
 eval [argument ...]
```
3. 举例  
```
1) foo=10 ， x=foo
2) y='$'$x
3) echo $y
4) $foo

5) eval y='$'$x
6) echo $y
7) 10
```

# Chmod用法
1. linux系统下的文件颜色含义  
绿色文件： 可执行文件，可执行的程序    
红色文件：压缩文件或者包文件  
蓝色文件：目录  
白色文件：一般性文件，如文本文件，配置文件，源码文件等  
浅蓝色文件：链接文件，主要是使用ln命令建立的文件  
红色闪烁：表示链接的文件有问题  
黄色：表示设备文件  
灰色：表示其他文件  


2. chmod +x的使用  
`chmod +x就是赋予用户文件的执行权限。若安装一个文件显示为没有操作权限，尝试sudo，以及chmod 777未解决，可使用chmod +x解决。`  
①　首先给执行权限：chmod +x 文件名（包括扩展后缀）
②　之后执行程序：./ 文件名（包括扩展后缀）

3.	chmod +x以及chmod u+x
chmod u+x代表设置某个用户获得执行文件的权限。

u 代表用户.
g 代表用户组.
o 代表其他.
a 代表所有

x 代表执行权限.
r 代表阅读权限.
w 代表书写权限
# linux中PATH=$PATH:$HOME/bin是什么意思

1. $HOME这个代码是一个环境变量，它代表的是当前登录的用户的主文件夹的意思。（就是家目录的那个）

2. $HOME/bin这个代码指的就是主文件夹下的bin子目录，代表的是文件夹的内部子目录。（注意不是根目录的那个）

3. PATH=$PATH:$HOME/bin这个代码是设置PATH环境变量。设置环境变量用等号，首先:冒号是分割符。Windows上面也有PATH环境变量，Windows的路径之间的分隔符是;分号。  
4. $PATH:$HOME/bin表示在保留原来的$PATH环境变量的基础上，再增加$HOME/bin这个路径作为新的$PATH环境变量。计算机中的变量有许多，主要应用于系统文件的管理方面。
# Cd用法

1、cd / 是跳转到根目录，根目录是所有用户共享的目录

2、cd ~ 是跳转到当前用户的家目录，如果是root用户，cd ~ 相当于 cd /root，如果是普通用户，cd ~ 相当于cd /home/当前用户名

3、cd /home 相当于查看有多少普通用户的家目录，因为所有的普通用户的父目录都是home目录
# Lsb-release
1. lsb_release显示发行版本信息  

LSB是Linux Standard Base的缩写， lsb_release命令 用来显示LSB和特定版本的相关信息。如果使用该命令时不带参数，则默认加上-v参数。

-v 显示版本信息  
-i 显示发行版的id  
-d 显示该发行版的描述信息  
-r 显示当前系统是发行版的具体版本号  
-c 发行版代号  
-a 显示上面的所有信息  
-h 显示帮助信息   

2. /etc/*release是系统安装时默认的发行版本信息，通常安装好系统后文件内容不会发生变化。  

3. uname  
① uname -r ：显示操作系统的发行版号  

② uname -a ：显示系统名、节点名称、操作系统的发行版号、操作系统版本、运行系统的机器 ID 号。  
-a, --all 所有的信息都按以下顺序打印，如果未知则省略-p和-i  

-s, --kernel-name print the kernel name打印内核名，系统名  
-n, --nodename print the network node hostname打印网络节点主机名  
-r, --kernel-release print the kernel release打印操作系统的发行版号  
-v, --kernel-version print the kernel version打印内核版本  
-m, --machine print the machine hardware name机器硬件（CPU）名  
-p, --processor print the processor type or "unknown"系统处理器的体系结构  
-i, --hardware-platform print the hardware platform or "unknown"打印硬件平台  
-o, --operating-system print the operating system打印操作系统  
--help display this help and exit  
--version output version information and exit  

